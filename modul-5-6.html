<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="./CSS/style-2.css" />
  </head>
  <body>
    <!--  1 -->
    <!-- Текст: расстояния между буквами
Расстояния между буквами определяется двумя способами:

letter-spacing со значениями
normal. Соответствует числу 0.
inherit. Значение получает от родительского элемента.
любое числовое значение в любых единицах измерения css (px, rem, em и т.п.). Отрицательные значения уменьшают расстояние, положительные - увеличивают.
Сочетанием text-align: justify вместе с word-spacing: normal
Задание
В коде html элемент ol с классом items содержит несколько потомков - элементы li c разными атрибутами. В коде css всем элементам, потомкам элемента с классом items задано расстояние между буквами в .25rem.

Задай классам item-less и item-normal свойство letter-spacing.
Значения для свойства letter-spacing возьми из значения атрибута data-letterspacing
Обрати внимание на наследование этого свойства. -->
    <ol class="items">
      <li class="item item-less" data-letterspacing="-.1rem">
        Свойство letter-spacing определяет межбуквенное расстояние в тексте.
      </li>
      <li class="item">
        <p>CSS свойство letter-spacing наследуется.</p>
      </li>
      <li class="item item-normal" data-letterspacing="normal">
        В отличие от значения 0, ключевое слово normal позволяет браузеру
        изменить расстояние между буквами для выравнивания текста.
      </li>
    </ol>
    <!-- 2 -->
    <!-- Блочная модель. Прямоугольник content box
Понимание механики блочной модели является базой для понимания того, как элементы размещаются на веб-странице. Большинство проблем в верстке возникает из-за неверного использования правил блочной модели.

В основе всего лежит content box - прямоугольная область в которой размещается контент (текст, изображения и т.п.)

Для описания геометрии прямоугольника браузер использует всего два свойства - width и height. В некоторых случаях разработчик может изменять значения этих свойств - например если значением display является block или inline-block. В других случая изменить значения width и height, заданные браузером нельзя - например если значением display является inline.

Следует запомнить три правила, которые необходимо вспоминать при изменении размещения элемента на странице с помощью css:

Значение высоты (height) для любых элементов браузер вычисляет на основе высоты контента.
Значение ширины (width) для элементов со значениями display равными inline или inline-block вычисляет на основе ширины контента.
Значение ширины (width) для элементов со значением display равным block равно 100% ширины (width) родительского элемента.
При размещении блоков content box действует особая "гравитация" - все элементы стремятся "упасть" вверх в левый угол.

Точкой отсчета для построения прямоугольника content box является верхний левый угол.

Внимание
Размещать блочные элементы внутри строчных запрещено.

Задание
Задай элементу с классом child ширину, равную половине ширины родительского элемента.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле. -->
    <div class="parent">
      <div class="child">У любого элемента высота задается по контенту.</div>
      <div class="child">
        У блочных элементов потомок занимает 100% ширины родительского элемента.
      </div>
      <div class="child">
        У блочных элементов можно задать размер контентной области - изменить
        width или height.
      </div>
    </div>
    <span class="parent">
      <i class="child">У любого элемента высота задается по контенту. </i>
      <i class="child">У строчных элементов ширина задается по контенту. </i>
      <i class="child"
        >У строчных элементов нельзя задать размер контентной области - изменить
        width или height.
      </i>
    </span>
    <!-- 3 -->
    <!-- Блочная модель: min-width
У блочных элементов контент может превышать заданные размеры content-area. Предотвратить уменьшение ширины меньше минимального размера поможет свойство min-width.

Ширина элемента не уменьшится меньше значения min-width, даже если значение width будет меньше. Если контента больше, то значение min-height позволяет высоте увеличиваться.

Задание
Задай элементу с классом child минимальную ширину, равную 200px.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле. -->
    <div class="parent">
      <div class="child">
        У блочных элементов контент может превышать заданные размеры
        content-area.
      </div>
      <div class="child">
        Ширина элемента не уменьшится меньше значения min-width, даже если
        значение width будет меньше.
      </div>
    </div>
    <span class="parent">
      <i class="child">У любого элемента высота задается по контенту. </i>
      <i class="child">У строчных элементов ширина задается по контенту. </i>
      <i class="child"
        >У строчных элементов нельзя задать размер контентной области - изменить
        width или height.
      </i>
    </span>
    <!-- 4 -->
    <!-- Блочная модель: max-width
У блочных элементов по умолчанию ширина принимает значение 100% ширины родителя. Если есть необходимость ограничить максимальную ширину элемента каким-то значением, следует использовать свойство max-width.

Ширина элемента не превысит значения max-width, даже если значение width будет больше.

Задание
Задай элементу с классом child максимальную ширину, равную 200px.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле. -->
    <div class="parent">
      <div class="child">
        Ширина элемента не превысит значения max-width, даже если значение width
        будет больше.
      </div>
    </div>
    <span class="parent">
      <i class="child">У любого элемента высота задается по контенту. </i>
      <i class="child">У строчных элементов ширина задается по контенту. </i>
      <i class="child"
        >У строчных элементов нельзя задать размер контентной области - изменить
        width или height.
      </i>
    </span>
    <!-- 5 -->
    <!-- Блочная модель: min-height
У любого элемента высота задается по контенту. Если контента нет, то высота равна 0. Если есть необходимость задать минимальную высоту, используйте min-height.

Высота элемента не уменьшится меньше значения min-height, даже если значение height будет меньше.

Свойство margin позволяет задавать расстояние между соседними элементами. Это свойство состоит из четырех более простых свойств по сторонам элемента

margin-top (верхняя сторона элемента)
margin-right (правая сторона элемента)
margin-bottom (нижняя сторона элемента)
margin-left (левая сторона элемента)
Задание
Задай элементу с классом parent

минимальную высоту, равную 30px;
отступ на нижней стороне элемента в 1rem (отступ от соседнего элемента).
Обрати внимание на отсутствие на веб-странице элемента с высотой 0 и его появление при задании значения свойству min-height. -->
    <div class="parent">
      <div class="child"></div>
    </div>
    <div class="parent">
      <div class="child">
        У любого элемента высота задается по контенту. Если контента нет, то
        высота равна 0. Если контента больше, то значение min-height позволяет
        высоте увеличиваться.
      </div>
    </div>
    <!-- 6 -->
    <!-- Блочная модель: height vs min-height
Если задана высота, а контента больше, чем может вместить content box, то контент выйдет за пределы элемента и перекроет элементы, расположенные ниже.

Значения min-height в подобной ситуации увеличит высоту до необходимого значения, сдвинув элементы, расположенные ниже. Таким образом в большинстве случаев min-height предпочтительнее height.

Задание
Замени значение height на min-height у элемента с классом card.

Обрати внимание на то как min-height исправил ситуацию с переполнением контента. -->
    <div class="card">
      <h4 clacc="card-title">Canvas</h4>
      <p class="card-description">
        В макете psd есть область, называемая canvas. Это область в которой
        дизайнер может что-то рисовать, а вне этой области программа рисовать не
        позволит. Ширина canvas - это не конкретная ширина экрана, а
        максимальная. Т.е. реальный экран может быть и больше или меньше - это
        не важно. В верстке это все равно ширина body, которую мы не задем.
        Потому что ширину body задает операционная система и браузер.
      </p>
    </div>
    <div class="card">
      <h4 clacc="card-title">Content box</h4>
      <p class="card-description">
        Для верстки важна максимальная ширина, внутри которой размещен контент.
        Обычно эту ширину ограничивают направляющие.
      </p>
    </div>
    <!-- 7 -->
    <!-- Блочная модель: padding и переопределение box-sizing
Свойство padding, как правило, используется для того, чтобы сместить content box и находящийся внутри контент от краев элемента. Это создает более эстетичный вид - подобно тому как в книгах, журналах или газетах контент (текст и фото) всегда расположены на некотором расстоянии от края листа.

Однако добавление padding (как и добавление border) изменяет геометрию блока, т.к. по умолчанию эти значения добавляются к размерам content box - т.е. добавляются к width или height.

Чтобы ширина блока оставалась как на макете, можно задать свойству box-sizing значение border-box. В этом случае значения вычитаются из размеров content box - т.е. width или height уменьшатся.

Уменьшение width или height может создать проблему для размещения контента при заданной ширине. Поэтому вместо height можно увеличить высоту задав свойство min-height.

Задание
Измени css свойства родительского элемента (элемента с классом parent) так, чтобы появились отступы от края до элемента-потомка, но ширина родительского элемента при этом осталась прежней. Для этого:

С помощью padding задай отступы в 1rem. Для описания значения padding используй самую короткую запись из одного значения.

Убедись, что геометрия (ширина) элемента с классом parent увеличилась на 2rem (за счет добавления ширины padding). Верни общую ширину блока к начальному значению, уменьшив content box с помощью изменения значения свойства box-sizing.

Перестал вмещаться контент? Замени у родителя и потомка свойство height на min-height. -->
    <div class="parent">
      <div class="child"></div>
    </div>
    <!-- 8 -->
    <!-- Блочная модель: проценты
нельзя задать значение в процентах только для border;
для padding и margin процент берется только от значения width вне зависимости от того какой из сторон задается значение;
width берет проценты от ширины родительской width;
height берет проценты от высоты родительской height.
Задание
Для элемента с классом child задайте с помощью процентов
ширину в половину от ширины родительского элемента;
высоту в половину от высоты родительского элемента;
padding-left в процентах (чтобы получился эквивалент 20px);
margin-top в процентах (чтобы получился эквивалент 40px).
Т.к. высота в процентах отсчитывается только от заданной высоты, то замени свойство min-height у элемента с классом parent на свойство height -->
    <div class="parent">
      <div class="child">
        <div class="inner">w100+h150</div>
      </div>
    </div>
    <!-- 9 -->
    <!-- Блочная модель: один из способов избежать выпадения вертикального отступа
Выпадение вертикального отступа происходит тогда, когда margin-top потомка превышает margin-top родительского элемента. В результате происходит смещение вниз как потомка, так и родителя.

Существует несколько способов избежать этого. В этом задании мы рассмотрим самый простой, но, из-за лишнего кода и изменения геометрии блоков, этот способ не является рекомендуемым.

Задание
Для элемента с классом parent задай верхнюю границу в 1px стиля solid прозрачного (transparent) цвета.

Убедитесь, что выпадение вертикального отступа исчезло. -->
    <div class="parent">
      <div class="child">
        <div class="inner">w100+h150</div>
      </div>
    </div>
    <!-- 10 -->
    <!-- Блочная модель: рекомендуемый способ избегать выпадения вертикального отступа и margin-collapse
Выпадение вертикального отступа и margin-collaps можно предотвратить, если придерживаться следующей тактики присваивания padding и margin:

родительскому элементу задавать padding вместо того, чтобы задавать дочернему элементу margin;
родительскому элементу не задавать margin-top, но задавать margin-bottom верхнему соседу.
Задание
Для элемента с классом child
удали свойство margin-top;
добавь свойство padding-top со значением 40px родительскому элементу.
Для элемента с классом parent добавь нижний отступ в 20px.

Обрати внимание, что никаких побочных эффектов от применения вертикальных значений margin не наблюдается. -->
    <div class="parent">
      <div class="child"></div>
    </div>
    <div class="parent">
      <div class="child"></div>
    </div>
    <!-- 11 -->
    <!-- Блочная модель: display: inline-block
inline-block это

ширина по контенту;
можно задавать width и height ;
нет обязательного переноса на новую строку.
Особенность inline-block состоит в том, что браузер рассматривает такие блоки как шрифт.

Это проявляется в первую очередь в том, что к этим элементам применяются css свойства для текста вроде text-align.

Еще одно неочевидное последствие рассмотрения inline-block как шрифта, состоит в появлении неожиданных символов пробелов, которые мешают правильно рассчитать размеры блоков.

Откуда появляются пробелы?

Каждая строка li начинается с новой строки, т.е. перед <li> находится знак переноса и пробелы.

<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>  
Браузер преобразует эти символы в символ пробела размером в 1/4 размера шрифта (как правило, но может быть больше или меньше в зависимости от шрифта).

Избавиться от этих пробелов можно разными способами. Один из них это изменение html, что делает текст html нечитабельным:

перед li нет ни пробелов, ни знаков переноса

<ul><li>1</li><li>2</li><li>3</li></ul>  
Еще один способ состоит в том, чтобы задать шрифту родительского элемента размер 0. Тогда оставшиеся пробелы получат ширину 0/4 , т.е. 0. Важно не забыть снова задать размер шрифта тексту внутри inline-block.

Попрактикуемся использовать второй прием.

Задание
Добейся размещения по 4 элемента с классом box в один ряд. Для этого

измени font-size элементу с классом container;
задай font-size элементу с классом box, со значением 1rem (это значение font-size задано body). -->
    <div class="container">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
      <div class="box">4</div>
      <div class="box">5</div>
      <div class="box">6</div>
      <div class="box">7</div>
      <div class="box">8</div>
      <div class="box">9</div>
      <div class="box">10</div>
      <div class="box">11</div>
      <div class="box">12</div>
    </div>
    <!-- 12 -->
    <!-- Блочная модель: display: inline-block
Практикуемся делать расчеты для отступов между блоками.

Задание
Добейся размещения по 3 элемента с классом box в один ряд с расстоянием от края в 15px и расстоянием между соседними элементами в 30px. Для этого задай одно свойство margin со значениями

0 для верхнего отступа (его заменяет padding-top родителя);
15px для нижнего отступа;
15px для левого и правого отступа. -->
    <div class="container">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
      <div class="box">4</div>
      <div class="box">5</div>
      <div class="box">6</div>
      <div class="box">7</div>
      <div class="box">8</div>
      <div class="box">9</div>
      <div class="box">10</div>
      <div class="box">11</div>
      <div class="box">12</div>
    </div>
    <!-- 13 -->
    <!-- 12. Псевдокласс nth-of-type() и nth-last-of-type
Еще одна модель размещения блоков. На этот раз у родительского элемента задан padding на все 4 стороны.

Задание
Добейся размещения по 3 элемента с классом box в один ряд с расстоянием от края в 0 и расстоянием между соседними элементами в 30px (сумма margin-left и margin-right). Для этого задай

margin-left: 0 для 1-го, 4-го, 7-го и 10-го элемента;
margin-right: 0 для 3-го, 6-го, 9-го и 12-го элемента;
margin-bottom: 0 для 10-го, 11-го и 12-го элемента. -->
    <div class="container">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
      <div class="box">4</div>
      <div class="box">5</div>
      <div class="box">6</div>
      <div class="box">7</div>
      <div class="box">8</div>
      <div class="box">9</div>
      <div class="box">10</div>
      <div class="box">11</div>
      <div class="box">12</div>
    </div>
    <!-- 1 -->
    <!-- Flex
Основные термины flex модели
Flex значительно упрощает верстку, но требует взамен

наличия контейнера, чтобы задать display: flex и потомков, чтобы к ним применились свойства и значения Flexbox Layout;
умение расположить потомков вдоль главной оси с помощью свойства justify-content. Можно расположить равномерно от края до края (space-between) или по центру (center) и другими способами;
умение расположить потомков вдоль вспомогательной оси с помощью свойства align-items, например по центру ;
и другие свойства, которые не рассматриваются в этой задаче.
Задание
Добейся размещения 3-х элементов с классом box в один ряд с расстоянием между соседними элементами в 30px без использования margin. Для этого задай элементу с классом container свойства с подходящими значениями
display для того чтобы flex модель применилась к потомкам;
justify-content для добавления равных отступов между блоками.
Размести текст (цифру) по центру элемента с классом box. Для этого задай элементу с классом box подходящие значения свойствам
display для того чтобы flex модель применилась к потомку - тексту;
justify-content для центрирования по горизонтали ;
align-items для центрирования по вертикали. -->
    <div class="container">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
    </div>
    <!-- 2 -->
    <!-- Flex: justify-content
Свойство justify-content позволяет размещать элементы вдоль главной оси.

Задание
У элемента с классом container padding-left и padding-right равны 0.

Добейся размещения 3-х элементов с классом box в один ряд с расстоянием между соседними элементами в 30px и по 15px по краям, без использования margin.

Для этого задай элементу с классом container подходящее значение для свойства justify-content. -->
    <div class="container">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
    </div>
    <!-- 3 -->
    <!-- Flex
Перенос потомков на новую строку

Flex стремиться разместить все элементы-потомки вдоль главной оси. Для этого модель Flex может изменять размеры прямых потомков. Если необходимо сохранить размеры и позволить перенос потомков на новую строку, то необходимо применить свойство flex-wrap со значением wrap - перенос.

Задание
Добейся размещения по 3 элемента классом box в один ряд с расстоянием между соседними элементами в 30px без использования margin. И с нижним отступом в 15px.
Для этого задай

элементу с классом container свойство flex-wrap со значением для переноса потомков на новую строку;
элементу с классом box свойство margin-bottom со значением отступа.
Обрати внимание, что у элемента с классом container значение свойства padding в 15px применятся к трем сторонам и не применятся к padding-bottom. -->
    <div class="container">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
      <div class="box">4</div>
      <div class="box">5</div>
      <div class="box">6</div>
      <div class="box">7</div>
      <div class="box">8</div>
      <div class="box">9</div>
      <div class="box">10</div>
      <div class="box">11</div>
      <div class="box">12</div>
    </div>
    <!-- 4 -->
    <!-- Flex
Вложение контейнера flex внутри другого контейнера flex

Любому потомку, находящемуся под действием свойства flex родительского элемента можно также задать свойство flex. Этот прием можно применять для размещения сложных конструкций, вроде логотипа и навигационного меню.

Попробуем использовать такое вложение на практике.

Задание
Добейся размещения в один ряд элементов внутри header. При этом элемент logo должен быть в левом углу, а меню - в правом.
Для этого задай элементу с классом container

display для того чтобы flex модель применилась к потомкам;
свойство justify-content для размещения элементов по краям родительского элемента;
свойство align-items для центрирования элементов по вертикали;
элементу с классом nav-menu  задай свойство display для того, чтобы flex модель применилась к потомкам. -->
    <header class="container">
      <div class="logo">
        <a href="#"><img src="./images/logo.png" alt="logo" width="50" /></a>
      </div>
      <ul class="nav-menu">
        <li class="nav-menu_item">
          <a href="#" class="nav-menu_link">link1</a>
        </li>
        <li class="nav-menu_item">
          <a href="#" class="nav-menu_link">link2</a>
        </li>
        <li class="nav-menu_item">
          <a href="#" class="nav-menu_link">link3</a>
        </li>
      </ul>
    </header>
    <!-- 5 -->
    <!-- Flex
Изменение положения одного элемента вопреки значению justify-content

Для того чтобы изменить положение для одного элемента (или определенной группы элементов), находящегося под действием свойства justify-content используют подходящее свойство margin-left или margin-right со значением auto.

Задание
Добейся размещения элемента с классом box-left в левом углу, не меняя положения элементов, расположенных в правом углу.
Для этого задай элементу с классом box-left подходящее свойство margin с нужным значением. -->
    <ul class="container">
      <div class="box box-left">left</div>
      <div class="box box-right">right 1</div>
      <div class="box box-right">right 2</div>
    </ul>
  </body>
</html>
